synchronized保证当前块中代码内容（对外部）的原子性、可见性和happens-before规则的顺序

可重入性，已经进入锁定的线程可直接获得当前锁，无须阻塞等待，重入采用计数机制
修饰静态方法的synchronized关键字锁住的是当前类对应的class对象，静态代码块需要锁住对应类.class
synchronized是JVM提供的锁保证，实现机制无须再编码层面关心

相应的，再说下Lock接口及其对应的一个实现ReentrantLock。
ReentrantLock顾名思义，至少保证了synchronized的可重入性，实际上Lock的实现基本上保证了synchronized的在并发开发中线程安全的所有特性

Lock（及其ReentrantLock实现）锁提供了lock()和unlock()方法，和synchronized的代码块进入和退出对应。
为了保证锁在发生异常的情况下锁得到解除，通常采用try-finally代码块的形式，并在finally中执行unlock()方法的调用
Lock（及其ReentrantLock实现）支持非阻塞等待，提供了tryLock()方法和按时间尝试的方法，获得锁失败则可以按需要直接返回，而不是死等下去，这在一定程度上避免了死锁和饿死的情况
不像Java提供的synchronized内在锁，Lock（及其ReentrantLock实现）还支持可中断锁，提供了lockInterruptibly()方法，在等待锁阻塞的时候，可以通过中断使其放弃等待
和内在锁以及内在锁对应的监视器等待队列机制不同，Lock和其对应的Condition接口都支持一个对象多个锁和条件对应，而非固有的一对一
还有，ReentrantLock的实现区分了公平锁和非公平锁，更灵活地适应需求场景

不是用来彻底取代synchronized的固有内在锁的，而是给开发者提供了特定需求场景下更灵活更方便的选择，Lock本身也有其缺点

在能够满足需求的情况下，应当优先选择synchronzied内在锁。

Java的线程实现最终都是基于硬件和操作系统平台之上的，这种阻塞和唤醒开销都是非常大的。
sun.misc.Unsafe的compareAndSwapInt()方法，乐观锁，java.util.concurrent.atomic中的大部分类都是基于乐观锁的思路做出实现。考虑到系统底层的阻塞和唤醒的成本考虑，乐观锁通常会比悲观锁效率更好一些。

对于synchronized和java.util.concurrent.locks包中的Lock实现的性能对比，在JDK1.5之前，并发量较大的时候，后者明显优于前者。但JavaSE6之后，JDK的实现对内在锁做了很大优化，单纯在性能方面的考虑，两种锁实现已经没有绝对的优劣差异了。


JavaSE6中的一些锁优化方案。

自旋锁。其实自旋简单理解就是线程不停地自己循环尝试获得锁，而非自旋锁未能获得的情况下一般是阻塞掉，之后再唤醒尝试获得锁。上面提到阻塞和唤醒是基于底层实现的，是有成本的。那在一定程度上，自旋虽然有计算资源上的损失但综合考虑这个成本，在多次自选后未能获得锁后再为避免浪费处理器计算资源将其阻塞掉。在JDK1.6之后，引入了自适应的概念，这点得到了一定优化。
锁消除。锁可能会带来阻塞等成本，那么没有锁自然就没有这些成本，在JDK判断得到对象只被单线程安全使用的情况下会把锁消除掉，以削减锁成本。
锁粗化。通常我们认为锁的粒度越小越好，以减少对不必要锁住的资源锁住，但有些情况刚好相反，锁过于细会导致一系列操作反复加锁解锁加锁解锁，在这种情况下，我们可以统一加锁一次解锁一次，削减了不必要的加锁解锁带来的成本。
轻量级锁和偏向锁则是在考虑仅仅在无竞争条件下的特殊优化处理，在发现竞争的时候又恢复到“重量级”锁状态，要结合情况考虑是否采用。更详细的原理这里不展开介绍



那么有没有一种更有效的解决方案使得这装状态依赖的线程间协作更有效率呢？那就是条件队列。当一个线程发现自己不满足条件时，将其挂载到某个条件下的队列中，直到条件满足时得到系统的通知。这样的方式就避免了对线程不必要的唤醒、锁获取和检查。当然，要做到这些需要底层的支持。在java.lang.Object中，采用native的方式实现了wait()/notify()/notifyAll()方法。这三个方法结合操作系统的实现给我们使用条件队列提供了方便。wait()所做的就是释放锁，等待条件发生，当前线程阻塞。notify()/notifyAll()则是通知满足条件的队列中的线程，将其唤醒。

类似的java.util.concurrent.locks中也给出了对应的实现，就是Condition，提供了更灵活的方法await()/signal()/signalAll()。下面一起说下线程协同需要注意的地方：

wait()/notify()/notifyAll()和await()/signal()/signalAll()都是会自动释放锁的，这就要求他们的执行必需在已经获得锁的代码块中
为了不错过通知信号，通常wait()会包含在一个循环中，而循环的条件往往就是可以继续向下执行的条件
对于JVM内在实现的条件队列，是和synchronized内在锁绑定的，只能对一个对象wait()，但条件可能是各种各样，这个就需要在while循环的条件中做不同的判断
notify()/notifyAll()的对比，后者更安全，保证能够被通知到，前者更有效率，不做不必要的唤醒。通常的建议是，除非保证等待条件和后续任务处理只有一类并且每次只需要一个线程被唤醒，否则优先考虑notifyAll()，惯例这样做是为了保证逻辑的正确性
Condition的await()/signal()和Object的wait()/notify()相比，是Java代码实现的框架，解开了一个对象只有一个条件队列的对应关系，可以根据需求调用Lock的newCondition()方法，每次调用开启一个新的条件队列，提高了队列的精确性
synchronized和wait()/notify()都是JVM的内在实现，是绑在一起的；Condition及其队列操作是基于AQS实现的，在SunJDK实现中用到了sun.misc.Unsafe类的park()和unpark()方法;内在条件队列与j.u.c的Condition实现的选择理由和synchronized和Lock的对比基本一致